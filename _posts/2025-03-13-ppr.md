---
toc: true
layout: post
title: PPR Blog
description: Improved PPR Blog
permalink: /posts/ppr
comments: True
---

### **1. Function (with parameters, if-else statement, and Sequencing + Selection + Iteration)**  
A function with parameters that includes sequencing, selection, and iteration is needed.  
We'll modify `addCard` in the frontend to include these elements.

#### **Code Snippet (Frontend - JavaScript)**
```javascript
function addCard(nolan) {
    const cards = document.querySelector(".cards");

    const card = document.createElement("div");
    card.classList.add("card");
    card.innerHTML = `<h3>${nolan.front}</h3>`;

    let isFlipped = false;

    // If-else selection
    if (!nolan.back) {
        card.innerHTML += "<p style='color: red;'>Back of card is missing</p>";
    }

    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "space-between";
    buttonContainer.style.width = "100%";

    const flipButton = document.createElement("button");
    flipButton.textContent = "Flip";
    flipButton.onclick = () => {
        if (isFlipped) {
            card.innerHTML = `<h3>${nolan.front}</h3>`;
        } else {
            card.innerHTML = `<h3>${nolan.back}</h3><p>${nolan.front}</p>`;
        }
        isFlipped = !isFlipped;
        card.appendChild(buttonContainer);
    };

    // Iteration: Process all buttons in an array
    const buttons = [flipButton];
    buttons.forEach(btn => buttonContainer.appendChild(btn));

    card.appendChild(buttonContainer);
    cards.appendChild(card);
}
```
#### **How This Fulfills the Requirement**  
- **Function with Parameters** → `addCard(nolan)` takes a `nolan` object.  
- **Sequencing** → The function executes in order: creating elements, appending them, and adding event listeners.  
- **Selection (If-Else)** → Checks if `nolan.back` exists and displays a warning if missing.  
- **Iteration (Loop)** → Uses `.forEach()` to iterate over button elements.

---

### **2. Call to Function**  
We need to show that a function is being called appropriately.

#### **Code Snippet (Backend - Python API)**
```python
def post(self):
    try:
        body = request.get_json()

        if not body or 'front' not in body or 'back' not in body:
            return {"message": "Invalid request. Missing front or back."}, 400

        new_nolan = Nolans(front=body['front'], back=body['back'])
        new_nolan.create()  # Function call

        return new_nolan.read(), 201
    except Exception as e:
        return {"message": f"Error adding nolan: {str(e)}"}, 500
```
#### **How This Fulfills the Requirement**  
- Calls the `create()` function on the `Nolans` model to save the card to the database.

---

### **3. List Creation**  
We need to create a list and process it.

#### **Code Snippet (Backend - Python API)**
```python
def get(self):
    nolans = Nolans.query.all()  # List creation
    return jsonify([nolan.read() for nolan in nolans])  # List processing
```
#### **How This Fulfills the Requirement**  
- **List Creation** → `nolans = Nolans.query.all()` retrieves multiple flashcards as a list.  
- **List Processing** → Uses a list comprehension `[nolan.read() for nolan in nolans]` to format data.

---

### **4. List Process**  
We need to iterate over a list and apply a function.

#### **Code Snippet (Frontend - JavaScript)**
```javascript
fetch(`${pythonURI}/api/flashcards`, fetchOptions)
  .then((res) => res.json())
  .then((nolans) => {
      nolans.forEach(addCard);  // Process each card in the list
  });
```
#### **How This Fulfills the Requirement**  
- **List Processing** → Iterates over `nolans` list using `.forEach()`.  
- **Function Application** → Calls `addCard(nolan)` for each flashcard.

