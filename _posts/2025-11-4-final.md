---
toc: true
layout: post
title: First Tri Final
description: Tri1 Final - CSA
permalink: /posts/csatrione
comments: True
---

# MCQ Performance

<img src="/nolan_2025/images/one/score.png" alt="score" />

I got a 37/42 on the Practice MCQ. I'm pretty happy about this performance and was honestly surprised, as I hadn't studied yet for the kind of stuff that would be on the MCQ.

<img src="/nolan_2025/images/one/breakdown.png" alt="breakdown" />

My strongest performance was in Data Collections, which was the largest by number of questions, and Using Methods and Objects was my lowest performing.

<img src="/nolan_2025/images/one/questions.png" alt="questions" />

## Corrections & Core Concepts

### Question 1: 2D Array Row Traversal

**Code:**

```java
public static int enigma(int[][] values, int x, int target)
{
   int result = 0;
   for (int num : values[x])
   {
      if (num == target)
      {
         result++;
      }
   }
   return result;
}
```

**My Answer:** Not answered  
**Correct Answer:** D - The number of times that an element equal to target appears in row x of values

**Explanation:**
The method counts occurrences of `target` in row `x` of the 2D array. The key is understanding that `values[x]` selects a specific row from the 2D array, and the enhanced for loop (`for (int num : values[x])`) traverses all elements in that row. Each time an element equals `target`, the counter `result` is incremented and returned at the end.

**Concept Summary: 2D Array Access**

- In Java 2D arrays, the **first index specifies the row**, the **second index specifies the column**
- `values[x]` returns an entire row (a 1D array)
- `values[x][y]` returns a specific element at row x, column y
- Enhanced for loops can iterate through a single row: `for (type element : array[row])`
- Think of 2D arrays as "arrays of arrays" - each row is itself an array

---

### Question 2: ArrayList Manipulation with add() Methods

**Code:**

```java
ArrayList<String> oldList = new ArrayList<String>();
oldList.add("a");
oldList.add("b");
oldList.add("c");

ArrayList<String> newList = new ArrayList<String>();
/* missing code */
```

**Goal:** `newList` should contain `["c", "b", "a", "a", "b", "c"]`

**My Answer:** D  
**Correct Answer:** B

**Why D is Wrong:**
Option D produces `[c, b, a, c, b, a]` instead of the desired output. Trace through:

- Iteration 1 (j=0, "a"): `add(0, "a")` → [a], then `add(0, "a")` → [a, a]
- Iteration 2 (j=1, "b"): `add(1, "b")` → [a, b, a], then `add(0, "b")` → [b, a, b, a]
- Iteration 3 (j=2, "c"): `add(2, "c")` → [b, a, c, b, a], then `add(0, "c")` → [c, b, a, c, b, a]

**Why B is Correct:**

```java
for (String s : oldList)
{
   newList.add(s);      // Add to end
   newList.add(0, s);   // Add to beginning
}
```

Trace through:

- Iteration 1 ("a"): `add("a")` → [a], then `add(0, "a")` → [a, a]
- Iteration 2 ("b"): `add("b")` → [a, a, b], then `add(0, "b")` → [b, a, a, b]
- Iteration 3 ("c"): `add("c")` → [b, a, a, b, c], then `add(0, "c")` → [c, b, a, a, b, c] ✓

**Concept Summary: ArrayList add() Methods**

- `add(element)` - appends to the **end** of the list
- `add(index, element)` - inserts at a **specific index**, shifting elements to the right
- `add(0, element)` - inserts at the **beginning** of the list
- When adding at an index, all elements at that index and beyond shift right
- Enhanced for loops iterate in order from index 0 to size-1

---

### Question 3: String Comparison and Counting Adjacent Duplicates

**Code:**

```java
String str = "abbcdddeff";
int j = 0;
int count = 0;
while (j < str.length() - 1)
{
   if (str.substring(j, j + 1).equals(str.substring(j + 1, j + 2)))
   {
      count++;
   }
   j++;
}
System.out.println(count);
```

**My Answer:** Not answered  
**Correct Answer:** C - 4

**Explanation:**
The code compares each character with the character immediately after it. Trace through the string "abbcdddeff":

- j=0: "a" vs "b" → not equal, count=0
- j=1: "b" vs "b" → **equal**, count=1 ✓
- j=2: "b" vs "c" → not equal, count=1
- j=3: "c" vs "d" → not equal, count=1
- j=4: "d" vs "d" → **equal**, count=2 ✓
- j=5: "d" vs "d" → **equal**, count=3 ✓
- j=6: "d" vs "e" → not equal, count=3
- j=7: "e" vs "f" → not equal, count=3
- j=8: "f" vs "f" → **equal**, count=4 ✓

Total: 4 pairs of adjacent duplicate characters

**Concept Summary: String Methods and Character Comparison**

- `substring(start, end)` - returns characters from index `start` to `end-1` (end is exclusive)
- `substring(j, j+1)` - returns a single character at index j as a String
- `equals()` - compares String content (not memory addresses like `==`)
- `str.length() - 1` in the loop condition prevents index out of bounds (can't compare last char with next)
- This pattern is common for comparing adjacent elements in sequences

---

### Question 4: Static Variables and Constructor Calls

**Code:**

```java
public class Shoe
{
   private static int count = 0;

   private double size;
   private String style;

   public Shoe()
   {
      size = 7.0;
      style = "boot";
   }

   public Shoe(double mySize, String myStyle)
   {
      size = mySize;
      style = myStyle;
      count++;
   }

   public static int getCount()
   {
      return count;
   }
}
```

**Test Code:**

```java
Shoe s1 = new Shoe(8.5, "sneaker");
Shoe s2 = new Shoe();
Shoe s3 = new Shoe(7.0, "sandal");
System.out.println(Shoe.getCount());
```

**My Answer:** A  
**Correct Answer:** C - 2

**Why A is Wrong:**
The static variable `count` starts at 0, but it gets incremented during execution, so the final answer cannot be 0.

**Explanation:**
Trace through the constructor calls:

- `Shoe s1 = new Shoe(8.5, "sneaker");` → calls two-parameter constructor → count++ → count = 1
- `Shoe s2 = new Shoe();` → calls no-parameter constructor → count stays 1 (no increment!)
- `Shoe s3 = new Shoe(7.0, "sandal");` → calls two-parameter constructor → count++ → count = 2
- Final count = 2

**Key Points:**

- The **no-parameter constructor does NOT increment count** (missing the `count++` statement)
- Only the **two-parameter constructor increments count**
- There are 2 calls to the two-parameter constructor (s1 and s3)

**Concept Summary: Static Variables and Constructors**

- `static` variables are **shared across all instances** of a class (class-level, not instance-level)
- There is only **one copy** of a static variable, regardless of how many objects are created
- Static variables persist across all object instantiations
- Different constructors can have different behaviors - always check what each one does
- Constructors don't automatically share code - each must explicitly modify static variables
- Access static variables/methods using the class name: `ClassName.staticMethod()`

---

### Question 5: Boolean Logic and De Morgan's Law

**Expression:** `!(isEven && isPositive) && isPrime`

**My Answer:** C  
**Correct Answer:** A - `(!isEven || !isPositive) && isPrime`

**Why C is Wrong:**
Test with values: `isEven = true`, `isPositive = false`, `isPrime = true`

Original: `!(true && false) && true` = `!false && true` = `true && true` = `true`

Option C: `(!true && !false) && true` = `(false && true) && true` = `false && true` = `false` ✗

The expressions don't match!

**Why A is Correct:**
Using the same values:

Option A: `(!true || !false) && true` = `(false || true) && true` = `true && true` = `true` ✓

**Explanation - De Morgan's Law:**
De Morgan's Law states:

- `!(A && B)` is equivalent to `!A || !B`
- `!(A || B)` is equivalent to `!A && !B`

Applying to our expression:

1. Start with: `!(isEven && isPositive) && isPrime`
2. Apply De Morgan's to the first part: `!(isEven && isPositive)` becomes `(!isEven || !isPositive)`
3. Keep the rest: `(!isEven || !isPositive) && isPrime`

**Concept Summary: De Morgan's Laws**

- **Negating AND:** `!(A && B)` = `!A || !B` (flip operator AND→OR, negate both terms)
- **Negating OR:** `!(A || B)` = `!A && !B` (flip operator OR→AND, negate both terms)
- **Mnemonic:** "Break the bar, change the sign" - when you break the negation bar over a compound statement, you change && to || (or vice versa) and negate each individual term
- These laws are fundamental to simplifying boolean expressions and are frequently tested on the AP exam
- When in doubt, create a truth table or test with specific boolean values

# Commits

[New Frontend](https://github.com/NoraTheTurtle/grinders/commits/main/?author=nulxn)
[Old Frontend](https://github.com/NoraTheTurtle/OLDgrinderss/graphs/contributors?from=8%2F2%2F2025)
[Spring](https://github.com/NoraTheTurtle/spring/graphs/contributors?from=10%2F4%2F2025)
[Analytics](https://pages.opencodingsociety.com/dashboard)

# Night at the Museum

<img src="/nolan_2025/images/one/crowd.png" alt="crowd" />
<img src="/nolan_2025/images/one/team.png" alt="team" />

## Positives & Negatives

* Got a lot of feedback
* The audience was respectful and engaged
* No technical difficulties

* The styling wasn't fully consistent
* Only a few of our audience members had technical backgrounds

## Feedback

* Improve frontend (basic changes - font color, sizing, etc.)
* Include more data for the resume (I plan on including data from module 2 to the resume to do this)
* Add more layout options